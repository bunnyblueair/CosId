(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{331:function(e,t,v){"use strict";v.r(t);var _=v(3),n=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"号段链模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#号段链模式"}},[e._v("#")]),e._v(" 号段链模式")]),e._v(" "),t("h2",{attrs:{id:"为什么需要segmentchainid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要segmentchainid"}},[e._v("#")]),e._v(" 为什么需要"),t("em",[e._v("SegmentChainId")])]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:e.$withBase("/assets/design/SegmentChainId.png"),alt:"SegmentChainId"}})]),e._v(" "),t("p",[e._v("通过"),t("strong",[e._v("SegmentChainId")]),e._v("设计图中我们可以看到，号段链模式新增了一个角色"),t("strong",[e._v("PrefetchWorker")]),e._v("。\n"),t("strong",[e._v("PrefetchWorker")]),e._v("主要的职责是维护和保证号段链头部到尾部的"),t("strong",[e._v("安全距离")]),e._v("，也可以近似理解为缓冲距离。\n有了安全距离的保障不难得出的结论是所有获取ID的线程只要从进程内存的号段里边获取下次ID即可，理想情况下不需要再进行"),t("code",[e._v("NextMaxId")]),e._v("（向号段分发器请求"),t("code",[e._v("NextMaxId")]),e._v("，网络IO）的，所以性能可以达到近似"),t("code",[e._v("AtomicLong")]),e._v(" 的 "),t("em",[e._v("TPS 性能:12743W+/s")]),e._v("的级别。")]),e._v(" "),t("p",[t("strong",[e._v("SegmentChainId")]),e._v("是"),t("strong",[e._v("SegmentId")]),e._v("的增强版，相比于"),t("strong",[e._v("SegmentId")]),e._v("有以下优势：")]),e._v(" "),t("ul",[t("li",[e._v("TPS性能：可达到近似 "),t("code",[e._v("AtomicLong")]),e._v(" 的 "),t("em",[e._v("TPS 性能:12743W+/s")]),e._v(" "),t("RouterLink",{attrs:{to:"/guide/docs/guide/perf-test.html"}},[e._v("JMH 基准测试")]),e._v("。通过引入了新的角色"),t("strong",[e._v("PrefetchWorker")]),e._v("用以维护和保证"),t("strong",[e._v("安全距离")]),e._v("，理想情况下使得获取ID的线程几乎完全不需要进行同步的等待"),t("code",[e._v("NextMaxId")]),e._v("获取。")],1),e._v(" "),t("li",[e._v("稳定性：P9999=0.208(us/op)，通过上面的TPS性能描述中我们可以看到，"),t("strong",[e._v("SegmentChainId")]),e._v("消除了同步等待的问题，所以稳定性问题也因此迎刃而解。")]),e._v(" "),t("li",[e._v("适应性：从"),t("strong",[e._v("SegmentId")]),e._v("介绍中我们知道了影响"),t("strong",[e._v("ID乱序")]),e._v("的因素有俩个：集群规模、"),t("code",[e._v("Step")]),e._v("大小。集群规模是我们不能控制的，但是"),t("code",[e._v("Step")]),e._v("是可以调节的。\n"),t("ul",[t("li",[t("code",[e._v("Step")]),e._v("应该尽可能小才能使得"),t("strong",[e._v("ID单调递增")]),e._v("的可能性增大。")]),e._v(" "),t("li",[t("code",[e._v("Step")]),e._v("太小会影响吞吐量，那么我们如何合理设置"),t("code",[e._v("Step")]),e._v("呢？答案是我们无法准确预估所有时点的吞吐量需求，那么最好的办法是吞吐量需求高时，Step自动增大，吞吐量低时Step自动收缩。")]),e._v(" "),t("li",[t("strong",[e._v("SegmentChainId")]),e._v("引入了"),t("strong",[e._v("饥饿状态")]),e._v("的概念，"),t("strong",[e._v("PrefetchWorker")]),e._v("会根据"),t("strong",[e._v("饥饿状态")]),e._v("检测当前"),t("strong",[e._v("安全距离")]),e._v("是否需要膨胀或者收缩，以便获得吞吐量与有序性之间的权衡，这便是"),t("strong",[e._v("SegmentChainId")]),e._v("的自适应性。")]),e._v(" "),t("li",[e._v("所以在使用"),t("strong",[e._v("SegmentChainId")]),e._v("时我们可以配置一个比较小的"),t("code",[e._v("Step")]),e._v("步长，然后由"),t("strong",[e._v("PrefetchWorker")]),e._v("根据吞吐量需求自动调节"),t("strong",[e._v("安全距离")]),e._v("，来自动伸缩步长。")])])])]),e._v(" "),t("h2",{attrs:{id:"redisidsegmentdistributor、jdbcidsegmentdistributor-均能够达到tps-1-2亿-s"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redisidsegmentdistributor、jdbcidsegmentdistributor-均能够达到tps-1-2亿-s"}},[e._v("#")]),e._v(" RedisIdSegmentDistributor、JdbcIdSegmentDistributor 均能够达到TPS=1.2亿/s？")]),e._v(" "),t("p",{attrs:{align:"center"}},[t("img",{attrs:{src:e.$withBase("/assets/perf/Throughput-Of-SegmentChainId.png"),alt:"Throughput-Of-SegmentChainId"}})]),e._v(" "),t("p",[e._v("上面的两张图给许多同学带来了困扰，为什么在"),t("code",[e._v("Step=1000")]),e._v("的时候"),t("em",[e._v("RedisIdSegmentDistributor")]),e._v("、"),t("em",[e._v("JdbcIdSegmentDistributor")]),e._v("TPS性能几乎一致(TPS=1.2亿/s)。\n"),t("em",[e._v("RedisIdSegmentDistributor")]),e._v("应该要比"),t("em",[e._v("JdbcIdSegmentDistributor")]),e._v("性能更高才对啊，为什么都能达到"),t("em",[e._v("AtomicLong")]),e._v("性能上限呢？\n如果我说当"),t("code",[e._v("Step=1")]),e._v("时，只要基准测试的时间够长，那么他们依然能够达到"),t("em",[e._v("AtomicLong")]),e._v("性能级别(TPS=1.2亿/s)，你会不会更加困惑。\n其实这里的"),t("em",[e._v("障眼法")]),e._v("是"),t("strong",[e._v("PrefetchWorker")]),e._v("的"),t("strong",[e._v("饥饿膨胀")]),e._v("导致的，"),t("em",[e._v("SegmentChainId")]),e._v("的极限性能跟分发器的TPS性能没有直接关系，因为最终都可以因饥饿膨胀到性能上限，只要给足够的时间膨胀。\n而为什么在上图的"),t("code",[e._v("Step=1")]),e._v("时TPS差异还是很明显的，这是因为"),t("em",[e._v("RedisIdSegmentDistributor")]),e._v("膨胀得更快，而基准测试又没有给足测试时间而已。")]),e._v(" "),t("p",[t("strong",[e._v("SegmentChainId")]),e._v("基准测试"),t("em",[e._v("TPS极限性能")]),e._v("可以近似使用以下的公式的表示：")]),e._v(" "),t("p",[t("code",[e._v("TPS(SegmentChainId)极限值=(Step*Expansion)*TPS(IdSegmentDistributor)*T/s<=TPS(AtomicLong)")])]),e._v(" "),t("ol",[t("li",[t("code",[e._v("<=TPS(AtomicLong)")]),e._v("：因为"),t("em",[e._v("SegmentChainId")]),e._v("的内部号段就是使用的"),t("code",[e._v("AtomicLong")]),e._v("，所以这是性能上限。")]),e._v(" "),t("li",[t("code",[e._v("Step*Expansion")]),e._v("："),t("em",[e._v("Expansion")]),e._v("可以理解为饥饿膨胀系数，默认的饥饿膨胀系数是2。在"),t("em",[e._v("MySqlChainIdBenchmark")]),e._v("、"),t("em",[e._v("MySqlChainIdBenchmark")]),e._v("基准测试中这个值是一样的。")]),e._v(" "),t("li",[t("code",[e._v("TPS(IdSegmentDistributor)")]),e._v(": 这是公式中唯一的不同。指的是请求号段分发器"),t("code",[e._v("NextMaxId")]),e._v("的TPS。")]),e._v(" "),t("li",[t("code",[e._v("T")]),e._v(": 可以理解为基准测试运行时常。")])]),e._v(" "),t("p",[e._v("从上面的公式中不难看出"),t("em",[e._v("RedisChainIdBenchmark")]),e._v("、"),t("em",[e._v("MySqlChainIdBenchmark")]),e._v("主要差异是分发器的TPS性能。\n分发器的"),t("code",[e._v("TPS(IdSegmentDistributor)")]),e._v("越大，达到"),t("code",[e._v("TPS(AtomicLong)")]),e._v("所需的"),t("code",[e._v("T")]),e._v("就越少。但只要"),t("code",[e._v("T")]),e._v("足够长，那么任何分发器都可以达到近似"),t("code",[e._v("TPS(AtomicLong)")]),e._v("。\n这也就解释了为什么不同TPS性能级别的号段分发器("),t("strong",[e._v("IdSegmentDistributor")]),e._v(")都可以达到TPS=1.2亿/s。")])])}),[],!1,null,null,null);t.default=n.exports}}]);